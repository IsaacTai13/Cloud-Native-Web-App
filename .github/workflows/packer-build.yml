name: Packer Build (on merge)

on:
  push:
    branches: [ main ] # treat "PR merged" as push to main
  pull_request:
    branches: [ main ]

permissions:
  contents: read

concurrency:
  group: packer-build-main
  cancel-in-progress: false

jobs:
  # --- Job 1: Integration tests + build artifact on runner ---
  build-artifact:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16
        ports:
          - "5432:5432"
        env:
          POSTGRES_USER: ${{ vars.DB_USERNAME }}
          POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
          POSTGRES_DB: ${{ vars.DB_NAME }}
        options: >-
          --health-cmd="pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=12

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      - name: Install Postgres client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Wait for Postgres to be ready
        run: |
          for i in {1..30}; do
            pg_isready -h ${{ vars.DB_HOST }} -p ${{ vars.DB_PORT }} -U ${{ vars.DB_USERNAME }} && break
            sleep 2
          done

      - name: Run tests (use ci profile)
        env:
          DB_HOST: ${{ vars.DB_HOST }}
          DB_PORT: ${{ vars.DB_PORT }}
          DB_NAME: ${{ vars.DB_NAME }}
          DB_USERNAME: ${{ vars.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_CONN_TIMEOUT_MS: ${{ vars.DB_CONN_TIMEOUT_MS }}
          SPRING_PROFILES_ACTIVE: ci
        run: mvn -B test

      - name: Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-reports-${{ github.run_id }}
          path: |
            **/target/surefire-reports/**
            **/target/failsafe-reports/**

      # Build the application artifact on the runner (not inside Packer image)
      - name: Build application
        run: mvn -B -DskipTests package

      # Zip the build output so Packer can upload it to EC2
      - name: Package artifact
        run: |
          mkdir -p packer/scripts
          zip -r packer/scripts/webapp.zip target/

      # Make the zip available to the next job
      - name: Upload artifact for Packer
        uses: actions/upload-artifact@v4
        with:
          name: webapp
          path: packer/scripts/webapp.zip
          if-no-files-found: error

  # --- Job 2: Build AMI with Packer (depends on Job 1 success) ---
  packer-build:
    runs-on: ubuntu-latest
    needs: build-artifact
    
    env:
      # --- AWS / Infra ---
      PKR_VAR_region: ${{ vars.AWS_REGION }}
      PKR_VAR_profile: ${{ vars.AWS_PROFILE }}
      PKR_VAR_vpc_id: ${{ vars.VPC_ID }}
      PKR_VAR_subnet_id: ${{ vars.SUBNET_ID }}
      PKR_VAR_security_group_id: ${{ vars.SECURITY_GROUP_ID }}
      PKR_VAR_demo_account_id: ${{ vars.DEMO_ACCOUNT_ID }}
      PKR_VAR_instance_type: ${{ vars.INSTANCE_TYPE }}
      PKR_VAR_ssh_username: ${{ vars.SSH_USERNAME }}

      # --- App / DB config ---
      PKR_VAR_shell_env: >-
        {
          "app_group": "${{ vars.APP_GROUP }}",
          "app_user": "${{ vars.APP_USER }}",
          "app_dir": "${{ vars.APP_DIR }}",
          "app_env_file": "${{ vars.APP_ENV_FILE }}",
          "app_archive_path": "/tmp",
          "app_archive_runner_path": "./scripts/webapp.zip",
          "service_name": "${{ vars.SERVICE_NAME }}"
        }

      PKR_VAR_web_env: >-
        {
          "db_conn_timeout_ms": "${{ vars.DB_CONN_TIMEOUT_MS }}",
          "server_port": "${{ vars.SERVER_PORT }}"
        }

    outputs:
      ami_id: ${{ steps.extract.outputs.ami_id }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: webapp
          path: packer/scripts/

      - name: Setup Packer
        uses: hashicorp/setup-packer@v2
        with:
          packer_version: 1.11.0

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
          aws-region:            ${{ vars.AWS_REGION }}

      - name: Versions
        run: |
          packer -v
          aws --version

      - name: Packer fmt/validate
        working-directory: packer
        run: |
          packer fmt -check -recursive .
          packer init .
          packer validate .

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Packer build
        working-directory: packer
        run: packer build .

      - name: Debug - Find manifest.json
        run: |
          echo "=== Current directory ==="
          pwd

          echo "=== Files in root ==="
          ls -la

          echo "=== Files in packer/ ==="
          ls -la packer/

          echo "=== Searching for manifest.json everywhere ==="
          find . -name "manifest.json" -type f

      - name: Extract AMI ID
        id: extract
        working-directory: packer
        run: |
          MANIFEST_PATH=$(find . -name "manifest.json" -type f | head -n 1)
    
          if [ -z "$MANIFEST_PATH" ]; then
          echo "ERROR: manifest.json not found!"
          exit 1
          fi
          
          echo "Found manifest at: $MANIFEST_PATH"
          AMI_ID=$(jq -r '.builds[0].artifact_id | split(":")[1]' "$MANIFEST_PATH")
          
          if [ -z "$AMI_ID" ] || [ "$AMI_ID" = "null" ]; then
            echo "Failed to extract AMI ID"
            cat "$MANIFEST_PATH"
            exit 1
          fi
    
          echo "AMI_ID=$AMI_ID"
          echo "ami_id=$AMI_ID" >> "$GITHUB_OUTPUT"

      - name: Share AMI with Demo account
        run: |
          aws ec2 modify-image-attribute \
            --image-id ${{ steps.extract.outputs.ami_id }} \
            --launch-permission "Add=[{UserId=${{ vars.DEMO_ACCOUNT_ID }}}]"


  deploy-demo:
    runs-on: ubuntu-latest
    needs: packer-build

    env:
      AMI_ID: ${{ needs.packer-build.outputs.ami_id }}
      ASG_NAME: ${{ vars.DEMO_ASG_NAME }}
      LAUNCH_TEMPLATE_ID: ${{ vars.DEMO_LT_ID }}
      AWS_REGION: ${{ vars.AWS_REGION }}

    steps:
      - name: Configure AWS (Demo)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEMO }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEMO }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create new Launch Template version
        # The last Export as env var for later steps if needed
        run: |
          NEW_VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-id "$LAUNCH_TEMPLATE_ID" \
            --source-version '$Latest' \
            --launch-template-data "{\"ImageId\":\"$AMI_ID\"}" \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)

          echo "NEW_VERSION=$NEW_VERSION"
          echo "NEW_VERSION=$NEW_VERSION" >> "$GITHUB_ENV"

      # Point the Auto Scaling Group to the latest Launch Template version
      - name: Update ASG to use latest Launch Template version
        run: |
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name "$ASG_NAME" \
            --launch-template "LaunchTemplateId=$LAUNCH_TEMPLATE_ID",Version='$Latest'

      # Start an instance refresh so the ASG gradually replaces old instances with new AMI
      - name: Start ASG instance refresh
        id: start-refresh
        run: |
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name "$ASG_NAME" \
            --query 'InstanceRefreshId' \
            --output text)

          echo "REFRESH_ID=$REFRESH_ID"
          echo "REFRESH_ID=$REFRESH_ID" >> "$GITHUB_OUTPUT"

      # Execute instance refresh and wait for it
      # Poll the instance refresh status until it completes or fails
      - name: Wait for instance refresh to complete
        run: |
          REFRESH_ID="${{ steps.start-refresh.outputs.REFRESH_ID }}"

          while true; do
            STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name "$ASG_NAME" \
              --instance-refresh-ids "$REFRESH_ID" \
              --query 'InstanceRefreshes[0].Status' \
              --output text)

            echo "Current status: $STATUS"

            if [ "$STATUS" = "Successful" ]; then
              echo "Instance refresh completed."
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ]; then
              echo "Instance refresh failed or was cancelled."
              exit 1
            fi

            sleep 30
          done